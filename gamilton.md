_Поступим следующим образом: заведем очередь и положим в нее все вершины нашего графа (не важно в каком порядке). Пусть n=|V|. Тогда n(n−1) раз будем делать следующую операцию:_

Пусть v1 — это голова очереди,
v2 — следующая за ней вершина и так далее.

Если между первой и второй вершиной в очереди есть ребро в графе G, то перемещаем первую вершину в конец очереди и переходим к следующей итерации.

Если между первой и второй вершиной в очереди ребра нет, то найдем вершину vi, где i>2, такую что, ребра v1vi,v2vi+1∈E

После чего поменяем в очереди местами вершины v2 и vi, v3 и vi−1, v2+j и vi−j, и так далее, пока 2+j<i−j 

Теперь у нас появилось ребро между первой и второй вершинами в очереди (теперь вторая вершина, это та, которая была до разворота на i-й позиции), а также, гарантированно существует ребро между i-й и (i+1)-й вершинами очереди. После этого, так же как и в первом случае, оправляем первую вершину в конец очереди.

Таким образом после n итераций, мы получаем последовательность (вершины лежащие в очереди), где любые 2 соседние вершины соединены ребром, все вершины графа находятся в этой последовательности, и более того, каждая ровно один раз, а также существует ребро между последней и первой вершинами очереди, а это и значит, что мы решили поставленную задачу.

**Таким образом после n итераций, мы получаем последовательность (вершины лежащие в очереди), где любые 2 соседние вершины соединены ребром, все вершины графа находятся в этой последовательности, и более того, каждая ровно один раз, а также существует ребро между последней и первой вершинами очереди, а это и значит, что мы решили поставленную задачу.**

Псевдокод:

```cpp
function findHamiltonianCycle(⟨V,E⟩):
     for v∈V:                                          // Добавляем все вершины графа в очередь
       queue.pushBack(v)
     for k = 0..n * (n - 1)
       if (queue.at(0), queue.at(1)) ∉E                // Проверяем существования ребра между первой и второй вершинами очереди
         i = 2                                             
         while (queue.at(0), queue.at(i)) ∉E or (queue.at(1), queue.at(i + 1)) ∉E
             i++                                         // Ищем индекс удовлетворяющую условию вершины
         queue.swapSubQueue(1, i)                        // Разворачиваем часть перестановки от 1-й до найденной позиции включительно
       queue.pushBack(queue.top())
       queue.pop()
```

```cpp
int gamilton(int k) {
    int v, q1 = 0;
    for (v = 0; v < n && !q1; v++) {
        if (a[v][path[k - 1]] || a[path[k - 1]][v]) {
            if (k == n && v == v0) q1 = 1;
            else if (c[v] == -1) {
                c[v] = k;
                path[k] = v;
                q1 = gamilton(k + 1);
                if (!q1) c[v] = -1;
            } else continue;
        }
    }
    return q1;
}
```